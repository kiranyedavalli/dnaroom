'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _set2 = require('lodash/set');

var _set3 = _interopRequireDefault(_set2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _dec, _dec2, _desc, _value, _obj; /*!
                                       * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
                                       */

/* eslint-env browser: true */
/* global RTCPeerConnection, RTCSessionDescription */

var _sparkCore = require('@ciscospark/spark-core');

var _common = require('@ciscospark/common');

var _internalPluginLocus = require('@ciscospark/internal-plugin-locus');

var _stateParsers = require('./state-parsers');

var _boolToStatus = require('./bool-to-status');

var _boolToStatus2 = _interopRequireDefault(_boolToStatus);

var _callMemberships = require('./call-memberships');

var _callMemberships2 = _interopRequireDefault(_callMemberships);

var _webRtcMedia = require('./web-rtc-media');

var _webRtcMedia2 = _interopRequireDefault(_webRtcMedia);

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _sdpTransform = require('sdp-transform');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @event ringing
 * @instance
 * @memberof Call
 * @deprecated with {@link config.phone.enableExperimentalGroupCallingSupport} enabled;
 * instead, listen for {@link Call.membership:notified}
 */

/**
 * @event connected
 * @instance
 * @memberof Call
 * @deprecated with {@link config.phone.enableExperimentalGroupCallingSupport} enabled;
 * instead, listen for {@link Call.active}
 */

/**
 * @event disconnected
 * @instance
 * @memberof Call
 * @deprecated with {@link config.phone.enableExperimentalGroupCallingSupport} enabled;
 * instead, listen for {@link Call.inactive}
 */

/**
 * @event active
 * @instance
 * @memberof Call
 * only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event initializing
 * @instance
 * @memberof Call
 * only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event inactive
 * @instance
 * @memberof Call
 * only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event terminating
 * @instance
 * @memberof Call
 * only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event localMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event remoteMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event error
 * @instance
 * @memberof Call
 */

/**
 * @event membership:notified
 * @instance
 * @memberof Call
 * @type {CallMembership}
 * This replaces the {@link Call.ringing} event, but note that it's subtly
 * different. {@link Call.ringing} is emitted when the remote party calls
 * {@link Call#acknowledge()} whereas {@link Call.membership:notified} emits
 * shortly after (but as a direct result of) locally calling
 * {@link Phone#dial()}
 */

/**
 * @event membership:connected
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:declined
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:disconnected
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:waiting
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:change
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event memberships:add
 * @instance
 * @memberof Call
 * Emitted when a new {@link CallMembership} is added to
 * {@link Call#memberships}. Note that {@link CallMembership#state} still needs
 * to be read to determine if the instance represents someone actively
 * participating the call.
 */

/**
 * @event memberships:remove
 * @instance
 * @memberof Call
 * Emitted when a {@link CallMembership} is removed from {@link Call#memberships}.
 */

/**
 * Payload for {@link Call#sendFeedback}
 * @typedef {Object} FeedbackObject
 * @property {number} userRating Number between 1 and 5 (5 being best) to let
 * the user score the call
 * @property {string} userComments Freeform feedback from the user about the
 * call
 * @property {Boolean} includeLogs set to true to submit client logs to the
 * Cisco Spark cloud. Note: at this time, all logs, not just call logs,
 * generated by the sdk will be uploaded to the Spark Cloud. Care has been taken
 * to avoid including PII in these logs, but if you've taken advantage of the
 * SDK's logger, you should make sure to avoid logging PII as well.
 */

/**
 * @class
 */
var Call = _sparkCore.SparkPlugin.extend((_dec = (0, _common.whileInFlight)('locusJoinInFlight'), _dec2 = (0, _common.whileInFlight)('locusLeaveInFlight'), (_obj = {
  namespace: 'Phone',

  children: {
    media: _webRtcMedia2.default
  },

  collections: {
    /**
     * @instance
     * @memberof Call
     * @type CallMemberships
     */
    memberships: _callMemberships2.default
  },

  session: {
    activeParticipantsCount: {
      default: 0,
      required: true,
      type: 'number'
    },
    /**
     * Indicates if the other party in the call has turned off their microphone.
     * `undefined` for multiparty calls
     * @instance
     * @memberof Call
     * @readonly
     * @type {boolean}
     */
    remoteAudioMuted: {
      default: false,
      required: false,
      type: 'boolean'
    },

    /**
     * Indicates if the other party in the call has turned off their camera.
     * `undefined` for multiparty calls
     * @instance
     * @memberof Call
     * @readonly
     * @type {boolean}
     */
    remoteVideoMuted: {
      default: false,
      required: false,
      type: 'boolean'
    },

    correlationId: 'string',
    /**
     * @instance
     * @memberof Call
     * @readonly
     * @type {string}
     */
    facingMode: {
      type: 'string',
      values: ['user', 'environment']
    },
    /**
     * Derived from locus.id and locus.fullState.lastActive. Not actually a
     * "derived" property because it shouldn't be reset in event a locus
     * replacement. Marked as private because this isn't necessarily the callId
     * that we'll eventually expose as a first-class feature.
     * @instance
     * @memberof Call
     * @private
     * @readonly
     * @type {string}
     */
    internalCallId: {
      setOnce: true,
      type: 'string'
    },
    locus: 'object',
    /**
     * Returns the local MediaStream for the call. May initially be `null`
     * between the time @{Phone#dial is invoked and the  media stream is
     * acquired if {@link Phone#dial} is invoked without a `localMediaStream`
     * option.
     *
     * This property can also be set mid-call in which case the streams sent to
     * the remote party are replaced by this stream. On success, the
     * {@link Call}'s {@link localMediaStream:change} event fires, notifying any
     * listeners that we are now sending media from a new source.
     * @instance
     * @memberof Call
     * @type {MediaStream}
     */
    localMediaStream: 'object',

    locusJoinInFlight: {
      default: false,
      type: 'boolean'
    },
    locusLeaveInFlight: {
      default: false,
      type: 'boolean'
    },
    /**
     * Test helper. Shortcut to the current user's membership object. not
     * official for now, but may get published at some point
     * @instance
     * @memberof Call
     * @private
     * @type {CallMembership}
     */
    me: {
      type: 'object'
    }
  },

  // Note, in its current form, any derived property that is an object will emit
  // a change event everytime a locus gets replaced, even if no values change.
  // For the moment, this is probably ok; once we have multi-party, regular
  // change events on activeParticipants may be a problem.
  derived: {
    id: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _get3.default)(this, 'locus.url');
      }
    },
    isActive: {
      deps: ['locus'],
      fn: function fn() {
        return !!(this.locus && (0, _stateParsers.isActive)(this.locus));
      }
    },
    joinedOnThisDevice: {
      deps: ['locus'],
      default: false,
      fn: function fn() {
        return !!(this.locus && (0, _stateParsers.joinedOnThisDevice)(this.spark, this.locus));
      }
    },
    locusUrl: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _get3.default)(this, 'locus.url');
      }
    },
    device: {
      deps: ['locus'],
      fn: function fn() {
        var _this = this;

        return this.locus.self && this.locus.self.devices.find(function (item) {
          return item.url === _this.spark.internal.device.url;
        });
      }
    },
    mediaConnection: {
      deps: ['locus'],
      fn: function fn() {
        var _this2 = this;

        var device = this.locus.self && this.locus.self.devices.find(function (item) {
          return item.url === _this2.spark.internal.device.url;
        });
        return (0, _get3.default)(device, 'mediaConnections[0]');
      }
    },
    mediaId: {
      deps: ['locus'],
      fn: function fn() {
        var _this3 = this;

        var device = this.locus.self && this.locus.self.devices.find(function (item) {
          return item.url === _this3.spark.internal.device.url;
        });
        return (0, _get3.default)(device, 'mediaConnections[0].mediaId');
      }
    },
    /**
     * The other participant in a two-party call. `undefined` for multiparty
     * calls
     * @instance
     * @memberof Call
     * @readyonly
     * @type {CallMembership}
     */
    remoteMember: {
      deps: ['memberships', 'locus'],
      fn: function fn() {
        if ((0, _stateParsers.isCall)(this.locus)) {
          return this.memberships.find(function (m) {
            return !m._self;
          });
        }

        return undefined;
      }
    },
    direction: {
      deps: ['locus'],
      fn: function fn() {
        // This seems brittle, but I can't come up with a better way. The only
        // way we should have a Call without a locus is if we just initiated a
        // call but haven't got the response from locus yet.
        if (!this.locus) {
          return 'out';
        }
        return (0, _stateParsers.direction)(this.locus);
      }
    },
    from: {
      deps: ['memberships'],
      fn: function fn() {
        if (this.isCall) {
          return this.memberships.find(function (m) {
            return m.isInitiator;
          });
        }
        return undefined;
      }
    },
    to: {
      deps: ['memberships'],
      fn: function fn() {
        if (this.isCall) {
          return this.memberships.find(function (m) {
            return !m.isInitiator;
          });
        }
        return undefined;
      }
    },
    /**
     * <b>active</b> - At least one person (not necessarily this user) is
     * participating in the call<br/>
     * <b>inactive</b> - No one is participating in the call<br/>
     * <b>initializing</b> - reserved for future use<br/>
     * <b>terminating</b> - reserved for future use<br/>
     * Only defined if
     * {@link config.phone.enableExperimentalGroupCallingSupport} has been
     * enabled
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    state: {
      deps: ['locus'],
      fn: function fn() {
        if (this.config.enableExperimentalGroupCallingSupport) {
          return (0, _stateParsers.getState)(this.locus);
        }

        return undefined;
      }
    },
    /**
     * <b>initiated</b> - Offer was sent to remote party but they have not yet
     * accepted <br>
     * <b>ringing</b> - Remote party has acknowledged the call <br>
     * <b>connected</b> - At least one party is still on the call <br>
     * <b>disconnected</b> - All parties have dropped <br>
     * <b>replaced</b> - In (hopefully) rare cases, the underlying data backing
     * a Call instance may change in such a way that further interaction with
     * that Call is handled by a different instance. In such cases, the first
     * Call's status, will transition to `replaced`, which is almost the same
     * state as `disconnected`. Generally speaking, such a transition should not
     * happen for a Call instance that is actively sending/receiving media.
     * @deprecated The {@link Call#status} attribute will likely be replaced by
     * the {@link Call#state}.
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    status: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _stateParsers.getStatus)(this.spark, this.locus, this.previousAttributes().locus);
      }
    },
    /**
     * Access to the remote party’s `MediaStream`.
     * @instance
     * @memberof Call
     * @member {MediaStream}
     * @readonly
     */
    remoteMediaStream: {
      deps: ['media.remoteMediaStream'],
      fn: function fn() {
        return this.media.remoteMediaStream;
      }
    },
    receivingAudio: {
      deps: ['media.receivingAudio'],
      fn: function fn() {
        return this.media.receivingAudio;
      }
    },
    receivingVideo: {
      deps: ['media.receivingVideo'],
      fn: function fn() {
        return this.media.receivingVideo;
      }
    },
    sendingAudio: {
      deps: ['media.sendingAudio'],
      fn: function fn() {
        return this.media.sendingAudio;
      }
    },
    sendingVideo: {
      deps: ['media.sendingVideo'],
      fn: function fn() {
        return this.media.sendingVideo;
      }
    },
    isCall: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _stateParsers.isCall)(this.locus);
      }
    },
    supportsDtmf: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _get3.default)(this, 'locus.self.enableDTMF');
      }
    }
  },

  /**
   * Use to acknowledge (without answering) an incoming call. Will cause the
   * initiator's Call instance to emit the ringing event.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  acknowledge: function acknowledge() {
    var _this4 = this;

    this.logger.info('call: acknowledging');
    return this.spark.internal.locus.alert(this.locus).then(function (locus) {
      return _this4._setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this4.logger.info('call: acknowledged');
    }));
  },

  // Note: the `whileInFlight` decorator screws up name inferrence, so we need
  // to include @name below.
  /**
   * Answers an incoming call.
   * @instance
   * @name answer
   * @memberof Call
   * @param {Object} options
   * @param {MediaStreamConstraints} options.constraints
   * @returns {Promise}
   */
  answer: function answer(options) {
    var _this5 = this;

    this.logger.info('call: answering');
    if (!this.locus) {
      this.logger.info('call: no locus provided, answer() is a noop');
      return _promise2.default.resolve();
    }
    // Locus may think we're joined on this device if we e.g. reload the page,
    // so, we need to check if we also have a working peer connection
    if (this.joinedOnThisDevice && this.media.peer) {
      this.logger.info('call: already joined on this device');
      return _promise2.default.resolve();
    }
    return this._join('join', this.locus, options).then((0, _common.tap)(function () {
      return _this5.logger.info('call: answered');
    }));
  },


  /**
   * Alias of {@link Call#reject}
   * @see {@link Call#reject}
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  decline: function decline() {
    return this.reject();
  },

  /**
   * Used by {@link Phone#dial} to initiate an outbound call
   * @instance
   * @memberof Call
   * @param {[type]} invitee
   * @param {[type]} options
   * @private
   * @returns {[type]}
   */
  dial: function dial(invitee, options) {
    var _this6 = this;

    this.locusJoinInFlight = true;
    this.logger.info('call: dialing');

    var locusMethodName = 'create';

    if (_common.base64.validate(invitee)) {
      // eslint-disable-next-line no-unused-vars
      var parsed = _common.base64.decode(invitee).split('/');
      var resourceType = parsed[3];
      var id = parsed[4];
      if (resourceType === 'PEOPLE') {
        invitee = id;
      }

      if (resourceType === 'ROOM') {
        if (!(0, _get3.default)(this, 'config.enableExperimentalGroupCallingSupport')) {
          throw new Error('Group calling is not enabled. Please enable config.phone.enableExperimentalGroupCallingSupport');
        }

        locusMethodName = 'join';
        invitee = {
          url: this.spark.internal.device.services.conversationServiceUrl + '/conversations/' + id + '/locus'
        };
      }
    }

    // Note: mercury.connect() will call device.register() if needed. We're not
    // using phone.register() here because it guarantees a device refresh, which
    // is probably unnecessary.
    this.spark.internal.mercury.connect().then(function () {
      return _this6._join(locusMethodName, invitee, options);
    }).then((0, _common.tap)(function () {
      return _this6.logger.info('call: dialed');
    })).catch(function (reason) {
      _this6.trigger('error', reason);
    }).then(function () {
      _this6.locusJoinInFlight = false;
    });

    return this;
  },


  /**
   * Disconnects the active call. Applies to both incoming and outgoing calls.
   * This method may be invoked in any call state and the SDK should take care
   * to tear down the call and free up all resources regardless of the state.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  hangup: function hangup() {
    var _this7 = this;

    // Note: not a @oneFlight because this function must call itself
    if (this.direction === 'in' && !this.joinedOnThisDevice) {
      return this.reject();
    }

    this.logger.info('call: hanging up');

    this.media.end();

    if (this.locusJoinInFlight) {
      this.logger.info('call: locus join in flight, waiting for rest call to complete before hanging up');
      return this.when('change:locusJoinInFlight').then(function () {
        return _this7.hangup();
      });
    }

    if (!this.locus) {
      this.stopListening(this.spark.internal.mercury);
      this.off();
      this.logger.info('call: hang up complete, call never created');
      return _promise2.default.resolve();
    }

    return this._hangup();
  },


  /**
   * Initializer
   * @instance
   * @memberof Call
   * @private
   * @param {Object} attrs
   * @param {Object} options
   * @returns {undefined}
   */
  initialize: function initialize() {
    var _this8 = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.initialize, this, args);

    this.listenTo(this.memberships, 'change:audioMuted', function () {
      if (_this8.remoteMember) {
        _this8.remoteAudioMuted = _this8.remoteMember.audioMuted;
      }
    });

    this.listenTo(this.memberships, 'change:videoMuted', function () {
      if (_this8.remoteMember) {
        _this8.remoteVideoMuted = _this8.remoteMember.videoMuted;
      }
    });

    this.on('change:remoteMember', function () {
      if (_this8.remoteMember) {
        _this8.remoteAudioMuted = _this8.remoteMember.audioMuted;
        _this8.remoteVideoMuted = _this8.remoteMember.videoMuted;
      } else {
        _this8.remoteAudioMuted = undefined;
        _this8.remoteVideoMuted = undefined;
      }
    });

    this.listenTo(this.memberships, 'add', function (model) {
      return _this8.trigger('memberships:add', model);
    });
    this.listenTo(this.memberships, 'remove', function (model) {
      return _this8.trigger('memberships:remove', model);
    });
    this.listenTo(this.memberships, 'change', function (model) {
      return _this8.trigger('membership:change', model);
    });
    this.listenTo(this.memberships, 'change:state', function (model) {
      _this8.activeParticipantsCount = _this8.memberships.filter(function (m) {
        return m.state === 'connected';
      }).length;

      _this8.trigger('membership:' + model.state, model);
    });

    if (this.locus) {
      this.internalCallId = (0, _stateParsers.makeInternalCallId)(this.locus);
    } else {
      this.once('change:locus', function () {
        _this8.internalCallId = (0, _stateParsers.makeInternalCallId)(_this8.locus);
      });
    }

    this.memberships.listenToAndRun(this, 'change:locus', function () {
      if (_this8.locus && _this8.locus.participants) {

        // Reminder: we're parsing here instead of CallMembership(s) so that we
        // can avoid making those classes spark aware and therefore keep them a
        // lot simpler
        _this8.memberships.set((0, _stateParsers.participantsToCallMemberships)(_this8.spark, _this8.locus));
        _this8.me = _this8.memberships.find(function (m) {
          return m._self;
        });
      }
    });

    this.listenTo(this.spark.internal.mercury, 'event:locus', function (event) {
      return _this8._onLocusEvent(event);
    });
    this.listenTo(this.spark.internal.mercury, 'event:locus.difference', function (event) {
      return _this8._onLocusEvent(event);
    });

    this.listenTo(this.media, 'error', function (error) {
      return _this8.trigger('error', error);
    });
    if (this.config.enableExperimentalGroupCallingSupport) {
      this.on('inactive', function () {
        process.nextTick(function () {
          _this8.stopListening();
          _this8.off();
        });
      });
    } else {
      this.on('disconnected', function () {
        // need to do this on next tick otherwise this.off() prevents remaining
        // events from being received (e.g. other listeners for `disconnected`
        // won't execute)
        process.nextTick(function () {
          _this8.stopListening(_this8.spark.internal.mercury);
          _this8.off();
        });
      });
    }
    this.on('replaced', function () {
      // need to do this on next tick otherwise this.off() prevents remaining
      // events from being received (e.g. other listeners for `disconnected`
      // won't execute)
      process.nextTick(function () {
        _this8.stopListening(_this8.spark.internal.mercury);
        _this8.off();
      });
    });

    this.listenTo(this.media, 'negotiationneeded', (0, _debounce3.default)(function () {
      _this8.media.createOffer().then(function () {
        return _this8._updateMedia({
          sdp: _this8.media.offerSdp,
          mediaId: _this8.mediaId
        });
      }).then(function () {
        return _this8._pollForExpectedLocus();
      }).then(function () {
        var sdp = JSON.parse(_this8.mediaConnection.remoteSdp).sdp;
        return _this8.media.acceptAnswer(sdp);
      }).catch(function (reason) {
        return _this8.emit('error', reason);
      });
    }));

    // Reminder: this is not a derived property so that we can reassign the
    // stream midcall
    this.on('change:media.localMediaStream', function () {
      _this8.localMediaStream = _this8.media.localMediaStream;
    });

    this.on('change:localMediaStream', function () {
      if (_this8.media.localMediaStream !== _this8.localMediaStream) {
        _this8.media.localMediaStream = _this8.localMediaStream;
      }

      if (_this8.facingMode) {
        var mode = (0, _get3.default)(_this8, 'media.videoConstraint.facingMode.ideal', (0, _get3.default)(_this8, 'media.videoConstraint.facingMode.ideal'));

        if (mode === 'user') {
          _this8.facingMode = 'user';
        }

        if (mode === 'environment') {
          _this8.facingMode = 'environment';
        }
      }
    });

    ['remoteMediaStream', 'localMediaStream', 'remoteAudioMuted', 'remoteVideoMuted'].forEach(function (key) {
      _this8.on('change:' + key, function () {
        return _this8.trigger(key + ':change');
      });
    });

    // This handler is untested because there's no way to provoke it. It's
    // probably actually only relevant for group calls.
    this.on('change:isActive', function () {
      if (!_this8.isActive) {
        if (_this8.joinedOnThisDevice) {
          _this8.logger.info('call: hanging up due to locus going inactive');
          _this8.hangup();
        }
      }
    });

    this.on('change:activeParticipantsCount', function () {
      if (!_this8.joinedOnThisDevice) {
        return;
      }

      if (_this8.activeParticipantsCount !== 1) {
        return;
      }

      if (_this8.isCall && !_this8.config.hangupIfLastActive.call) {
        return;
      }

      if (!_this8.isCall && !_this8.config.hangupIfLastActive.meeting) {
        return;
      }

      var previousLocus = _this8.previousAttributes().locus;
      if (!previousLocus) {
        return;
      }

      if ((0, _stateParsers.activeParticipants)(previousLocus).length > 1) {
        _this8.logger.info('call: hanging up due to last participant in call');
        _this8.hangup();
      }
    });

    this.on('change:status', function () {
      process.nextTick(function () {
        return _this8.trigger(_this8.status);
      });
    });

    this.on('change:state', function () {
      if (_this8.config.enableExperimentalGroupCallingSupport) {
        process.nextTick(function () {
          return _this8.trigger(_this8.state);
        });
      }
    });
  },

  /**
   * Rejects an incoming call. Only applies to incoming calls. Invoking this
   * method on an outgoing call is a no-op.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  reject: function reject() {
    var _this9 = this;

    if (this.direction === 'out') {
      return _promise2.default.resolve();
    }

    this.logger.info('call: rejecting');
    /* eslint no-invalid-this: [0] */
    return this.spark.internal.locus.decline(this.locus).then(function (locus) {
      return _this9._setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this9.stopListening(_this9.spark.internal.mercury);
    })).then((0, _common.tap)(function () {
      return _this9.off();
    })).then((0, _common.tap)(function () {
      return _this9.logger.info('call: rejected');
    }));
  },


  /**
   * Send DTMF tones to the current call
   * @param {string} tones
   * @returns {Promise}
   */
  sendDtmf: function sendDtmf(tones) {
    if (!this.supportsDtmf) {
      return _promise2.default.reject(new Error('this call does not support dtmf'));
    }

    return this.spark.internal.locus.sendDtmf(this.locus, tones);
  },


  /**
   * Sends feedback about the call to the Cisco Spark cloud
   * @instance
   * @memberof Call
   * @param {FeedbackObject} feedback
   * @returns {Promise}
   */
  sendFeedback: function sendFeedback(feedback) {
    return this.spark.internal.metrics.submit('meetup_call_user_rating', feedback);
  },
  startReceivingAudio: function startReceivingAudio() {
    return this._changeReceivingMedia('offerToReceiveAudio', true);
  },
  startReceivingVideo: function startReceivingVideo() {
    return this._changeReceivingMedia('offerToReceiveVideo', true);
  },


  /**
   * Starts sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingAudio: function startSendingAudio() {
    return this._changeSendingMedia('audio', true);
  },


  /**
   * Starts sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingVideo: function startSendingVideo() {
    return this._changeSendingMedia('video', true);
  },
  stopReceivingAudio: function stopReceivingAudio() {
    return this._changeReceivingMedia('offerToReceiveAudio', false);
  },
  stopReceivingVideo: function stopReceivingVideo() {
    return this._changeReceivingMedia('offerToReceiveVideo', false);
  },


  /**
   * Stops sending audio to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingAudio: function stopSendingAudio() {
    return this._changeSendingMedia('audio', false);
  },


  /**
   * Stops sending video to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingVideo: function stopSendingVideo() {
    return this._changeSendingMedia('video', false);
  },


  /**
   * Replaces the current mediaStrem with one with identical constraints, except
   * for an opposite facing mode. If the current facing mode cannot be
   * determined, the facing mode will be set to `user`. If the call is audio
   * only, this function will throw.
   * @instance
   * @memberof Call
   * @returns {undefined}
   */
  toggleFacingMode: function toggleFacingMode() {
    var _this10 = this;

    var constraints = {
      audio: (0, _assign2.default)({}, this.media.audioConstraint),
      video: this.media.videoConstraint
    };

    if (!constraints.video) {
      throw new Error('Cannot toggle facignMode on audio-only call');
    }

    if (this.facingMode !== 'user' && this.facingMode !== 'environment') {
      throw new Error('Cannot determine current facing mode; specify a new localMediaStream to change cameras');
    }

    if (constraints.video === true) {
      constraints.video = {
        facingMode: {
          ideal: this.facingMode
        }
      };
    }

    if (this.facingMode === 'user') {
      (0, _set3.default)(constraints, 'video.facingMode.ideal', 'environment');
    } else {
      (0, _set3.default)(constraints, 'video.facingMode.ideal', 'user');
    }

    return this.spark.phone.createLocalMediaStream(constraints).then(function (stream) {
      return new _promise2.default(function (resolve) {
        _this10.media.once('answeraccepted', resolve);
        _this10.localMediaStream = stream;
      });
    }).then(function () {
      _this10.facingMode = constraints.video.facingMode.ideal || constraints.video.facingMode.exact;
    });
  },


  /**
   * Toggles receiving audio from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingAudio: function toggleReceivingAudio() {
    return this.receivingAudio ? this.stopReceivingAudio() : this.startReceivingAudio();
  },


  /**
   * Toggles receiving video from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingVideo: function toggleReceivingVideo() {
    return this.receivingVideo ? this.stopReceivingVideo() : this.startReceivingVideo();
  },


  /**
   * Toggles sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingAudio: function toggleSendingAudio() {
    return this.sendingAudio ? this.stopSendingAudio() : this.startSendingAudio();
  },


  /**
   * Toggles sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingVideo: function toggleSendingVideo() {
    return this.sendingVideo ? this.stopSendingVideo() : this.startSendingVideo();
  },
  _changeReceivingMedia: function _changeReceivingMedia(key, value) {
    var _this11 = this;

    return new _promise2.default(function (resolve) {
      _this11.once('change:receiving' + (key === 'offerToReceiveAudio' ? 'Audio' : 'Video'), function () {
        return resolve();
      });
      _this11.media.set(key, value);
    });
  },
  _changeSendingMedia: function _changeSendingMedia(key, value) {
    var _this12 = this;

    return new _promise2.default(function (resolve) {
      var sdp = (0, _sdpTransform.parse)(_this12.media.offerSdp);
      var section = (0, _find3.default)(sdp.media, { type: key });
      // If the current offer is going to trigger a renegotiation, then we don't
      // need to renegotiate here.
      if (!section || !section.direction.includes('send')) {
        _this12.media.once('answeraccepted', resolve);
      } else {
        _this12.once('change:sending' + (key === 'audio' ? 'Audio' : 'Video'), function () {
          return resolve(_this12._updateSendingMedia());
        });
      }
      _this12.media.set(key, value);
    });
  },

  /**
   * Does the internal work necessary to end a call while allowing hangup() to
   * call itself without getting stuck in promise change because of oneFlight
   * @private
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  _hangup: function _hangup() {
    var _this13 = this;

    return this.spark.internal.locus.leave(this.locus).then(function (locus) {
      return _this13._setLocus(locus);
    })
    // Note: not stopping event-listening here; that'll happening
    // automatically when `disconnected` fires.
    .then((0, _common.tap)(function () {
      return _this13.logger.info('call: hung up');
    }));
  },

  // The complexity in _join is largely driven up by fairly readable `||`s
  // eslint-disable-next-line complexity
  _join: function _join(locusMethodName, target) {
    var _this14 = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


    if (options.localMediaStream) {
      this.media.set('localMediaStream', options.localMediaStream);
    } else {
      if (!options.constraints) {
        options.constraints = {
          audio: true,
          video: {
            facingMode: {
              ideal: this.spark.phone.defaultFacingMode
            }
          }
        };
      }
      var mode = (0, _get3.default)(options, 'constraints.video.facingMode.ideal', (0, _get3.default)(options, 'constraints.video.facingMode.exact'));
      if (mode === 'user' || mode === 'environment') {
        this.facingMode = mode;
      }

      var recvOnly = !options.constraints.audio && !options.constraints.video;
      options.offerOptions = (0, _defaults3.default)(options.offerOptions, {
        offerToReceiveAudio: recvOnly || !!options.constraints.audio,
        offerToReceiveVideo: recvOnly || !!options.constraints.video
      });
    }

    var mediaOptions = {};
    if (options.constraints) {
      mediaOptions.audio = options.constraints.audio;
      mediaOptions.video = options.constraints.video;
    }

    if (options.offerOptions) {
      mediaOptions.offerToReceiveAudio = options.offerOptions.offerToReceiveAudio;
      mediaOptions.offerToReceiveVideo = options.offerOptions.offerToReceiveVideo;
    }

    if (mediaOptions.offerOptions || options.constraints) {
      this.media.set(mediaOptions);
    }

    if (!target.correlationId) {
      this.correlationId = options.correlationId = _uuid2.default.v4();
    }

    if (!this.correlationId) {
      this.correlationId = target.correlationId;
    }

    // reminder: not doing this copy in initialize() because config may not yet
    // be available
    this.media.bandwidthLimit = {
      audioBandwidthLimit: this.config.audioBandwidthLimit,
      videoBandwidthLimit: this.config.videoBandwidthLimit
    };

    return this.media.createOffer().then(function () {
      return _this14.spark.internal.locus[locusMethodName](target, {
        localSdp: _this14.media.offerSdp,
        correlationId: _this14.correlationId
      });
    }).then(function (locus) {
      return _this14._setLocus(locus);
    }).then(function () {
      var answer = JSON.parse(_this14.mediaConnection.remoteSdp).sdp;
      _this14.logger.info('accepting offer');
      _this14.logger.info('peer state', _this14.media.peer && _this14.media.peer.signalingState);
      if (!_this14.media.ended) {
        return _this14.media.acceptAnswer(answer).then(function () {
          return _this14.logger.info('offer accepted');
        });
      }
      _this14.logger.info('call: already ended, not accepting answer');
      return _promise2.default.resolve();
    });
  },


  /**
   * Handles an incoming mercury event if relevant to this call.
   * @instance
   * @memberof Call
   * @param {Types~MercuryEvent} event
   * @private
   * @returns {undefined}
   */
  _onLocusEvent: function _onLocusEvent(event) {
    var _this15 = this;

    var devices = (0, _get3.default)(event, 'data.locus.self.devices');
    var device = devices && (0, _find3.default)(devices, function (item) {
      return item.url === _this15.spark.internal.device.url;
    });
    if (this.locus && (0, _stateParsers.makeInternalCallId)(event.data.locus) === this.internalCallId || device && this.correlationId && this.correlationId === device.correlationId) {
      this.logger.info('locus event: ' + event.data.eventType);
      this._setLocus(event.data.locus);
    }

    if (event.data.locus.replaces) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(event.data.locus.replaces), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var replaced = _step.value;

          if (replaced.locusUrl + '_' + replaced.lastActive === this.internalCallId) {
            this._setLocus(event.data.locus);
            this.logger.info('locus replacement event: ' + event.data.eventType, this.locusUrl, '->', event.data.locus.url);
            return;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  },

  /**
   * The response to a PUT to LOCUS/media may not be fully up-to-date when we
   * receive it. This method polls locus until we get a locus with the status
   * properties we expect (or three errors occur)
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise<Types~Locus>}
   */
  _pollForExpectedLocus: function _pollForExpectedLocus() {
    var _this16 = this;

    return new _promise2.default(function (resolve) {
      try {
        _this16._validateLocusMediaState(_this16.locus);
        resolve();
      } catch (err) {
        _this16.logger.warn('locus: received locus does not contain expected state; fetching again');
        resolve(_this16.spark.internal.locus.sync(_this16.locus).then(function (locus) {
          return _this16._setLocus(locus);
        }).then(function () {
          return _this16._validateLocusMediaState(_this16.locus);
        }));
      }
    });
  },


  /**
   * Assigns a new locus to this.locus according to locus sequencing rules
   * @instance
   * @memberof Call
   * @param {Types~Locus} incoming
   * @param {boolean} recursing - when true, indicates that this method has
   * called itself and we should fall back to {@link locus.get()} instead of
   * calling {@link locus.sync()}
   * @private
   * @returns {Promise}
   */
  _setLocus: function _setLocus(incoming) {
    var _this17 = this;

    var recursing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var current = this.locus;
    if (!current) {
      this.locus = incoming;
      return _promise2.default.resolve();
    }
    var action = this.spark.internal.locus.compare(current, incoming);

    switch (action) {
      case _internalPluginLocus.USE_INCOMING:
        this.locus = this.spark.internal.locus.merge(this.locus, incoming);
        if (this.device) {
          this.correlationId = this.device.correlationId;
        }
        break;
      case _internalPluginLocus.FETCH:
        if (recursing) {
          this.logger.info('call: fetching locus according to sequencing algorithm');
          return this.spark.internal.locus.get(current).then(function (locus) {
            return _this17._setLocus(locus, true);
          });
        }

        this.logger.info('call: syncing locus according to sequencing algorithm');

        return this.spark.internal.locus.sync(current).then(function (locus) {
          return _this17._setLocus(locus, true);
        });

      default:
      // do nothing
    }

    return _promise2.default.resolve();
  },


  /**
   * Changes the status of media
   * @instance
   * @memberof Call
   * @param {Object} payload
   * @private
   * @returns {Promise}
   */
  _updateMedia: function _updateMedia(payload) {
    var _this18 = this;

    if (payload.sdp && !payload.sdp.includes('b=')) {
      throw new Error('outbound sdp should always have a \'b=\' line');
    }
    return this.spark.internal.locus.updateMedia(this.locus, payload).then(function (locus) {
      return _this18._setLocus(locus);
    });
  },

  /**
   * Changes the status of outbound media
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  _updateSendingMedia: function _updateSendingMedia() {
    var _this19 = this;

    return this._updateMedia({
      sdp: this.media.offerSdp,
      mediaId: this.mediaId,
      audioMuted: !this.sendingAudio,
      videoMuted: !this.sendingVideo
    }).then(function () {
      return _this19._waitForExpectedLocus();
    });
  },


  /**
   * Checks that this.locus has the expected state
   * @instance
   * @memberof Call
   * @param {Types~Locus} locus
   * @private
   * @returns {Promise}
   */
  _validateLocusMediaState: function _validateLocusMediaState(locus) {
    var locusAudio = locus.self.status.audioStatus.toLowerCase();
    var mediaAudio = (0, _boolToStatus2.default)(this.media.audio, this.media.offerToReceiveAudio);
    if (locusAudio !== mediaAudio) {
      this.logger.warn('locus: expected audio ' + locusAudio + ' (locus) to equal ' + mediaAudio + ' (local media)');
      throw new Error('locus.self.status.audioStatus indicates the received DTO is out of date');
    }

    var locusVideo = locus.self.status.videoStatus.toLowerCase();
    var mediaVideo = (0, _boolToStatus2.default)(this.media.video, this.media.offerToReceiveVideo);
    if (locusVideo !== mediaVideo) {
      this.logger.warn('locus: expected video ' + locusVideo + ' (locus) to equal ' + mediaVideo + ' (local media)');
      throw new Error('locus.self.status.videoStatus indicates the received DTO is out of date');
    }

    return locus;
  },


  /**
   * Waits until this.locus describes the expected state
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  _waitForExpectedLocus: function _waitForExpectedLocus() {
    var _this20 = this;

    return new _promise2.default(function (resolve) {
      var listener = function listener() {
        try {
          _this20._validateLocusMediaState(_this20.locus);
          _this20.off('change:locus', listener);
          resolve();
        } catch (err) {
          _this20.logger.warn('locus: current locus not in expected state; waiting for next locus');
        }
      };
      _this20.on('change:locus', listener);
      listener();
    });
  },
  version: '1.12.2'
}, (_applyDecoratedDescriptor(_obj, 'acknowledge', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'acknowledge'), _obj), _applyDecoratedDescriptor(_obj, 'answer', [_common.oneFlight, _dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'answer'), _obj), _applyDecoratedDescriptor(_obj, 'dial', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'dial'), _obj), _applyDecoratedDescriptor(_obj, 'reject', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'reject'), _obj), _applyDecoratedDescriptor(_obj, '_hangup', [_common.oneFlight, _dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, '_hangup'), _obj), _applyDecoratedDescriptor(_obj, '_join', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_join'), _obj), _applyDecoratedDescriptor(_obj, '_pollForExpectedLocus', [_common.retry], (0, _getOwnPropertyDescriptor2.default)(_obj, '_pollForExpectedLocus'), _obj), _applyDecoratedDescriptor(_obj, '_updateSendingMedia', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_updateSendingMedia'), _obj)), _obj)));

Call.make = function make(attrs, options) {
  return new Call(attrs, options);
};

exports.default = Call;